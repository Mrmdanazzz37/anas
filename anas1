import heapq
import matplotlib.pyplot as plt
import networkx as nx

def dijkstra(graph, start):
    # Initialize distances and previous node tracker
    distance = {node: float('inf') for node in graph}
    previous_node = {node: None for node in graph}
    distance[start] = 0
    queue = [(0, start)]
    
    while queue:
        curr_dist, node = heapq.heappop(queue)
        
        # If the current distance is greater than the known shortest distance, skip it
        if curr_dist > distance[node]:
            continue
        
        for neighbor, weight in graph[node].items():
            dist = curr_dist + weight
            if dist < distance[neighbor]:
                distance[neighbor] = dist
                previous_node[neighbor] = node
                heapq.heappush(queue, (dist, neighbor))

    return distance, previous_node

def reconstruct_path(previous_node, start, end):
    path = []
    while end is not None:
        path.insert(0, end)
        end = previous_node[end]
    if path[0] == start:  # If start node is part of the path
        return path
    return []

def draw_graph(graph, shortest_paths=None, start=None, end=None):
    G = nx.Graph()

    for node in graph:
        for neighbor, weight in graph[node].items():
            G.add_edge(node, neighbor, weight=weight)

    pos = nx.spring_layout(G)
    edge_labels = nx.get_edge_attributes(G, 'weight')

    nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=1000)
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)

    # Highlight the shortest path
    if shortest_paths and start and end:
        path = reconstruct_path(shortest_paths, start, end)
        path_edges = [(path[i], path[i + 1]) for i in range(len(path) - 1)]
        nx.draw_networkx_edges(G, pos, edgelist=path_edges, edge_color='red', width=2)

    plt.title("Energy Optimization Graph")
    plt.show()

if __name__ == "__main__":
    # Define a weighted undirected graph
    graph = {
        'A': {'B': 2, 'C': 1, 'D': 1},
        'B': {'A': 2, 'C': 2, 'D': 1},
        'C': {'A': 1, 'B': 2, 'D': 2},
        'D': {'A': 1, 'B': 1, 'C': 2}
    }
    
    # Calculate shortest paths from node 'A'
    start_node = 'A'
    shortest_distances, previous_nodes = dijkstra(graph, start_node)

    # Draw the graph with shortest path from 'A' to 'D' highlighted
    draw_graph(graph, previous_nodes, start=start_node, end='D')

    # Print shortest distances
    print(f"Shortest distances from node {start_node}:")
    for node, dist in shortest_distances.items():
        print(f"{node}: {dist}")
